---
title: "R Programming Week2"
output: html_document
---


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

Objectives:

Write an if-else expression
Write a for loop, a while loop, and a repeat loop
Define a function in R and specify its return value [see Functions Part 1 and Part 2]
Describe how R binds a value to a symbol via the search list
Define what lexical scoping is with respect to how the value of free variables are resolved in R
Describe the difference between lexical scoping and dynamic scoping rules
Convert a character string representing a date/time into an R datetime object. [see Dates and Times]

```{r}

#For loops 


x<- c("a","b","c","d")

for (i in 1:4) { print(x[i])}

for ( i in seq_along(x)) { print(x[i])}

for (letter in x) {print(letter)}

# Nested for loops 

x<- matrix(1:6, 2, 3)

for( i in seq_len(nrow(x))) { 
        
        for (j in seq_len(ncol(x)))
        { print(x[i,j])
                
        }
}

#While
#be careful when to end  

```

First function

```{r}
#First function


#above10

above10 <- function(x){
        use<- x>10 
        x[use]
        
}

above<- function(x,n=10){
        use<- x>n
        x[use]
        
}

#Matrix column mean
columnmean<- function(y, removeNA= TRUE) {
        nc<- ncol(y)
        means<- numeric(nc)
        for (i in 1:nc) { 
                means[i]<- mean(y[,i], na.rm=removeNA )}
        means
        
}

#Functions Part I

#Argument Matching

#The "... argument in the functions indicates the pass along to other functions. will address more in the future



#Lexical Scoping ######
make.power<- function(n){
        pow <- function(x) {
                x^n
        }
        pow
}

cube<- make.power(3)#only specify n, does not specify x.
cube 
cube(3)# the 3 here is specifying x

square<- make.power(2)
square(3)

#Looking for functions' environment

ls(environment(cube))
get("n",environment(cube))



#Dates
x<- as.Date("2012-01-01")
y<- strptime("9 Jan 2011 11:34:21", "%d %b %Y %M:%S")
x
y
x-y

x<- as.POSIXlt(x)
x
x-y


```

Swirl Practice

Logical operator

```{r}
# & evaluates all
# && evaluate the first member of a vector (operand)


# | is "or" , evaluates the whole vector (operand)
# same logic, || only evaluates the first member of a right operand
TRUE | c(TRUE, FALSE, FALSE)


5 > 8 || 6 != 8 && 4 > 3.9
#First, the && is evaluated, is true
#Then, 5<8 is false, so now is FALSE || TRUE
# || only evaluates the first element of the right operand, hence, it is true.



#isTRUE
isTRUE(6>4)

#identical()

#xor() : Stands for the exclusive "OR"
#If there is a or, then it will be TRUE.
#If there is not a or (two arguments are the same), then will be FALSE

xor( 5==6, !FALSE) # (FALSE,TRUE) ==> TRUE

#which() : return the location of the true value 
ints <- sample(10)
which(ints>7)

#any() : return Ture if one or more of the elements are true
#all(): if all of the elements are true
```



Swirl practice: Functions
```{r}

# %% : Return the remainder

remainder <- function(num, divisor=2) {
 num %% divisor
        
}

# See function's arguments:

args(remainder)

#Paste: concatenate

telegram <- function(...){
        paste("START",...,"STOP")
  
}

```


Data frame
```{r}

#Create Matrix

my_matrix2<- matrix(1:20,nrow=4, ncol=5)
my_matrix<- matrix(1:9,byrow=TRUE,ncol=5) #byrow= filled by the rows

#Cbind: combine column ( add a column)

patients<- c("Bill","Gina","Kelly","Sean")
cbind(patients,my_matrix2) #Note: the numbers will become "" because matrix can only have one type of data


#Data frame: can have different kinds of data

my_data<- data.frame(patients,my_matrix2)

#Create names for columns

cnames<-c("patient","age","weight","bp","rating","test")

colnames(my_data)<-cnames

#Same, use rownames to create for rows






```


